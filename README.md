# Экосистема языка программирования C$ (Си-якорь).
```
Прогресс создания …

… компилятора (не прямого типа — JIT/AOT формы), компиляция в промежуточное представление — байт-код:
[●···································································································] 1/100%

… интерпретатора (виртуально(-го/-ой) процессора/машины):
[●●●●●·······························································································] 5/100%

… компилятора (прямого типа — AOT форма), компиляция в машинный/нативный/оп-код для архитектуры процессоров x86 (CISC) под OS Windows/Biome:
[····································································································] 0/100%


Общий прогресс:
[●●··································································································] 2/100%
```
```
-- - - - - - - - - - - - - --
Compiler C$ (C-anchor) v.0.1
-- - - - - - - - - - - - - --

 ca file_name.ca +p preprocessed_files/file_name.ca -c=asm               -c=bc                ; Вариант 1: Препроцессорная обработка (видимая), без этапа компиляции
 ca file_name.ca +p preprocessed_files/file_name.ca +c=asm file_name.asm -c=bc                ; Вариант 2: Препроцессорная обработка (видимая) -> Компиляция в язык ассемблера ВМ (видимая)
 ca file_name.ca +p                                 +c=asm file_name.asm -c=bc                ; Вариант 3: Препроцессорная обработка (скрытая) -> Компиляция в язык ассемблера ВМ (видимая)
 ca file_name.ca +p                                 +c=asm               +c=bc file_name.bin  ; Вариант 4: Препроцессорная обработка (скрытая) -> Компиляция в язык ассемблера ВМ (скрытая) + Компиляция в байт-код (видимая)
 ca file_name.ca -p                                 +c=asm file_name.asm +c=bc file_name.bin  ; Вариант 5: Компиляция в язык ассемблера ВМ (видимая) -> Компиляция в байт-код (видимая)
 ca file_name.ca -p                                 +c=asm               +c=bc file_name.bin  ; Вариант 6: Компиляция в язык ассемблера ВМ (скрытая) -> Компиляция в байт-код (видимая)
 ca file_name.ca -p                                 -c=asm               +c=bc file_name.bin  ; Вариант 7: Компиляция в байт-код (видимая) ; Минует этап препроцессинга и ассемблерного кода (как видимого, так и скрытого)

Вариант 8: Компиляция в сырой (двоичный/бинарный) код
 ; под OS Windows
 ca file_name.ca -p                                 -c=asm               +c=bin file_name.bin
 ca file_name.ca +p                                 -c=asm               +c=bin file_name.bin

 ; под OS Linux
 ca file_name.ca -p                                 -c=asm               +c=bin file_name
 ca file_name.ca +p                                 -c=asm               +c=bin file_name

 ; под OS Biome
 ca file_name.ca -p                                 -c=asm               +c=bin file_name
 ca file_name.ca +p                                 -c=asm               +c=bin file_name

Вариант 9: Компиляция в объектный модуль
 ca file_name.ca -c file_name.o   ; под OS Linux
 ca file_name.ca -c file_name.obj ; под OS Windows
 ca file_name.ca -c file_name     ; под OS Biome

Вариант 10: Компиляция в машинный код (исполняемый файл)
 ca file_name.ca -c file_name     ; под OS Linux
 ca file_name.ca -c file_name.exe ; под OS Windows
 ca file_name.ca -c -b file_name  ; под OS Biome


Опции флагов:

-p            ; Игнорировать препроцессорную обработку (По умолчанию)
+p            ; Запустить скрытый процесс препроцессора
+p file_name  ; Запустить видимый процесс препроцессора

-c=bytecode            ; --
+c=bytecode            ; --
+c=bytecode file_name  ; Запустить видимый процесс компиляции в байт-код

-c=asm            ; Игнорировать компиляцию в ассемблерный код (По умолчанию)
+c=asm            ; Запустить скрытый процесс компиляции в ассемблерный код
+c=asm file_name  ; Запустить видимый процесс компиляции в ассемблерный код

-c=bin            ; --
+c=bin            ; --
+c=bin file_name  ; Запустить видимый процесс компиляции в бинарный (сырой) код
```
``` Таблица команд интерпретатора ```
```
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
     Байт (СС)             Мнемоническая символика (синтаксис)
¦ в 16-й ¦ в 10-й ¦ Символ ¦ на ассемблере ¦ на bf-подобном ¦ Операция
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
¦ 2B     ¦ 043    ¦ +      ¦ INC/inc       ¦ +              ¦ Инкремент
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
¦ 2D     ¦ 045    ¦ -      ¦ DEC/dec       ¦ -              ¦ Декремент
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
¦ 3C     ¦ 060    ¦ <      ¦               ¦ <              ¦ Смещение указателя на позицию назад
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
¦ 3D     ¦ 061    ¦ =      ¦ JMP/jmp       ¦                ¦ Смещение в определённую позицию
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
¦ 3E     ¦ 062    ¦ >      ¦               ¦ >              ¦ Смещение указателя на позицию вперёд
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
¦ 2E     ¦ 046    ¦ .      ¦               ¦ .              ¦ Считывание (получение) данных из памяти
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --
¦ 2C     ¦ 044    ¦ ,      ¦               ¦ ,              ¦ Считывание (установка) данных в память
-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --

ADD/add | Сложение
SUB/sub | Вычитание
MUL/mul | Умножение
DIV/div | Деление
CALL/call | Вызвать процедуру
PUSH/push | Положить на верхушку стека
POP/pop | Снять со стека
RET/ret | Вернуться из процедуры
LOOP/loop | Повторить действия
CMP/cmp | Сравнение
JZ/jz | Прыгни если ноль   // Jump if Zero / if (!cmp('$', '$')){} / if (1){}
JE/je | Прыгни если равно  // Jump if Equal / if (!cmp('$', '$')){} / if (1){}
```
